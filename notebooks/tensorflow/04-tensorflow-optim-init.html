
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Initialization and Optimization &#8212; 𝗜𝗻𝗲𝗳𝗳𝗶𝗰𝗶𝗲𝗻𝘁 𝗡𝗲𝘁𝘄𝗼𝗿𝗸𝘀</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet">
  <link href="../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="shortcut icon" href="../../_static/pone.0237978.g001.png"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Convolutional Neural Networks" href="05-tensorflow-cnn.html" />
    <link rel="prev" title="Activation Functions" href="03-tensorflow-activations.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/pone.0237978.g001.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">𝗜𝗻𝗲𝗳𝗳𝗶𝗰𝗶𝗲𝗻𝘁 𝗡𝗲𝘁𝘄𝗼𝗿𝗸𝘀</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  MLOPS ZOOMCAMP
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../mlops/01-intro/notes.html">
   Preliminaries
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mlops/02-mlflow/notes.html">
   Experiment Tracking and Model Management
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mlops/03-prefect/notes.html">
   Orchestration and ML Pipelines
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mlops/04-deployment/notes.html">
   Model Deployment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mlops/05-monitoring/notes.html">
   Model Monitoring
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mlops/06-best-practices/notes.html">
   Best practices
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  MODEL DEPLOYMENT
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../deployment/production-code.html">
   Packaging Production Code
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../deployment/model-serving-api.html">
   Prediction Serving API
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../deployment/docker.html">
   Containerization with Docker
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../deployment/cicd-pipelines.html">
   Continuous Integration and Deployment Pipelines
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  FUNDAMENTALS
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../fundamentals/pipelines.html">
   Modelling with Pipelines
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fundamentals/blending-stacking.html">
   Blending and Stacking
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fundamentals/optuna.html">
   Hyperparameter Optimization using Optuna
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fundamentals/missing.html">
   Handling Missing Values
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  DEEP LEARNING
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../fundamentals/backpropagation.html">
   Backpropagation on DAGs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="01-tensorflow-nn.html">
   TensorFlow Datasets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="02-tensorflow-mechanics.html">
   Mechanics of TensorFlow
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="03-tensorflow-activations.html">
   Activation Functions
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Initialization and Optimization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="05-tensorflow-cnn.html">
   Convolutional Neural Networks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="06-tensorflow-rnns.html">
   Recurrent Neural Networks
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/notebooks/tensorflow/04-tensorflow-optim-init.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/particle1331/inefficient-networks"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/particle1331/inefficient-networks/issues/new?title=Issue%20on%20page%20%2Fnotebooks/tensorflow/04-tensorflow-optim-init.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   Introduction
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#preliminaries">
   Preliminaries
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#initialization">
   Initialization
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#constant-initialization">
     Constant initialization
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#constant-variance">
     Constant variance
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#how-to-find-appropriate-initialization-values">
     How to find appropriate initialization values
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#initialization-for-tanh-networks">
       Initialization for Tanh networks
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#initialization-for-relu-networks">
       Initialization for ReLU networks
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#understanding-activation-and-gradient-flow">
     Understanding activation and gradient flow
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#optimization">
   Optimization
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#optimization-algorithms">
     Optimization algorithms
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#sgd">
       SGD
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#sgd-with-momentum">
       SGD with Momentum
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#adam">
       Adam
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#comparing-optimizers-on-model-training">
     Comparing optimizers on model training
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#testing-optimizers-on-exotic-surfaces">
     Testing optimizers on exotic surfaces
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#pathological-curvatures">
       Pathological curvatures
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#steep-optima">
       Steep optima
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#what-optimizer-to-take">
     What optimizer to take
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conclusion">
   Conclusion
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Initialization and Optimization</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   Introduction
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#preliminaries">
   Preliminaries
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#initialization">
   Initialization
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#constant-initialization">
     Constant initialization
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#constant-variance">
     Constant variance
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#how-to-find-appropriate-initialization-values">
     How to find appropriate initialization values
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#initialization-for-tanh-networks">
       Initialization for Tanh networks
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#initialization-for-relu-networks">
       Initialization for ReLU networks
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#understanding-activation-and-gradient-flow">
     Understanding activation and gradient flow
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#optimization">
   Optimization
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#optimization-algorithms">
     Optimization algorithms
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#sgd">
       SGD
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#sgd-with-momentum">
       SGD with Momentum
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#adam">
       Adam
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#comparing-optimizers-on-model-training">
     Comparing optimizers on model training
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#testing-optimizers-on-exotic-surfaces">
     Testing optimizers on exotic surfaces
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#pathological-curvatures">
       Pathological curvatures
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#steep-optima">
       Steep optima
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#what-optimizer-to-take">
     What optimizer to take
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conclusion">
   Conclusion
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="initialization-and-optimization">
<h1>Initialization and Optimization<a class="headerlink" href="#initialization-and-optimization" title="Permalink to this headline">¶</a></h1>
<p><img alt="Status" src="https://img.shields.io/static/v1.svg?label=Status&amp;message=Finished&amp;color=brightgreen" />
<a class="reference external" href="https://github.com/particle1331/inefficient-networks/blob/master/docs/notebooks/tensorflow/04-tensorflow-optim-init.ipynb"><img alt="Source" src="https://img.shields.io/static/v1.svg?label=GitHub&amp;message=Source&amp;color=181717&amp;logo=GitHub" /></a>
<a class="reference external" href="https://github.com/particle1331/inefficient-networks"><img alt="Stars" src="https://img.shields.io/github/stars/particle1331/inefficient-networks?style=social" /></a></p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>𝗔𝘁𝘁𝗿𝗶𝗯𝘂𝘁𝗶𝗼𝗻: Based on Tutorial 4: Optimization and Initialization. The original tutorial is written in PyTorch and is part of a lecture series on Deep Learning at the University of Amsterdam. The adapted version here is published with kind permission of the author.
</pre></div>
</div>
<hr class="docutils" />
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>In this notebook, we will review techniques for optimization and initialization of neural networks. When increasing the depth of neural networks, there are various challenges we face. Most importantly, we need to have a stable gradient flow through the network, as otherwise, we might encounter vanishing or exploding gradients. This is why we will take a closer look at the following concepts: <strong>initialization</strong> and <strong>optimization</strong>.</p>
<p>In the first half of the notebook, we will review different initialization techniques, and go step by step from the simplest initialization to methods that are nowadays used in very deep networks. In the second half, we focus on optimization comparing the optimizers SGD, SGD with Momentum, and Adam.</p>
<br><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="kn">import</span> <span class="nn">tensorflow_datasets</span> <span class="k">as</span> <span class="nn">tfds</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">import</span> <span class="nn">tensorflow.keras</span> <span class="k">as</span> <span class="nn">kr</span>


<span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s2">&quot;once&quot;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">matplotlib_inline</span> <span class="kn">import</span> <span class="n">backend_inline</span>
<span class="n">backend_inline</span><span class="o">.</span><span class="n">set_matplotlib_formats</span><span class="p">(</span><span class="s1">&#39;svg&#39;</span><span class="p">)</span>

<span class="n">seed</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
<span class="n">tf</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">list_physical_devices</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[PhysicalDevice(name=&#39;/physical_device:CPU:0&#39;, device_type=&#39;CPU&#39;), PhysicalDevice(name=&#39;/physical_device:GPU:0&#39;, device_type=&#39;GPU&#39;)]
2.8.0
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="preliminaries">
<h2>Preliminaries<a class="headerlink" href="#preliminaries" title="Permalink to this headline">¶</a></h2>
<p>Throughout this notebook, we will use a deep fully connected network, similar to our previous tutorial. We will also again apply the network to FashionMNIST, so you can relate to the results in the previous notebook. We start by loading the FashionMNIST dataset:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">transform_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sample_mean</span><span class="p">,</span> <span class="n">sample_std</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Flatten image and standardize pixel-wise over batch.&quot;&quot;&quot;</span>
    
    <span class="n">image</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)),</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">image</span> <span class="o">-</span> <span class="n">sample_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">sample_std</span>


<span class="c1"># Load training data</span>
<span class="n">FMNIST</span><span class="p">,</span> <span class="n">FMNIST_info</span> <span class="o">=</span> <span class="n">tfds</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
    <span class="s1">&#39;fashion_mnist&#39;</span><span class="p">,</span> 
    <span class="n">data_dir</span><span class="o">=</span><span class="s1">&#39;./data&#39;</span><span class="p">,</span> 
    <span class="n">with_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
    <span class="n">shuffle_files</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
<span class="n">train_ds</span><span class="p">,</span> <span class="n">test_ds</span> <span class="o">=</span> <span class="n">FMNIST</span><span class="p">[</span><span class="s1">&#39;train&#39;</span><span class="p">],</span> <span class="n">FMNIST</span><span class="p">[</span><span class="s1">&#39;test&#39;</span><span class="p">]</span>

<span class="c1"># Get pixel-wise sample statistics</span>
<span class="n">images</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">train_ds</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="mi">60000</span><span class="p">)))[</span><span class="s1">&#39;image&#39;</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">784</span><span class="p">))</span>
<span class="n">images</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">sample_mean</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">sample_std</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">reduce_std</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Preprocess input data</span>
<span class="n">train_ds</span> <span class="o">=</span> <span class="n">train_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">transform_image</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">],</span> <span class="n">sample_mean</span><span class="p">,</span> <span class="n">sample_std</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]))</span>
<span class="n">test_ds</span> <span class="o">=</span> <span class="n">test_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">transform_image</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">],</span> <span class="n">sample_mean</span><span class="p">,</span> <span class="n">sample_std</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]))</span>

<span class="c1"># For all our analysis, we fix one batch</span>
<span class="n">fixed_batch</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">train_ds</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="mi">4096</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Metal device set to: Apple M1

systemMemory: 8.00 GB
maxCacheSize: 2.67 GB
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2022-07-18 05:06:09.981253: I tensorflow/core/common_runtime/pluggable_device/pluggable_device_factory.cc:305] Could not identify NUMA node of platform GPU ID 0, defaulting to 0. Your kernel may not have been built with NUMA support.
2022-07-18 05:06:09.982316: I tensorflow/core/common_runtime/pluggable_device/pluggable_device_factory.cc:271] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 0 MB memory) -&gt; physical PluggableDevice (device: 0, name: METAL, pci bus id: &lt;undefined&gt;)
2022-07-18 05:06:10.145081: W tensorflow/core/platform/profile_utils/cpu_utils.cc:128] Failed to get CPU frequency: 0 Hz
</pre></div>
</div>
</div>
</div>
<p>The normalization is now designed to give us an expected mean of <code class="docutils literal notranslate"><span class="pre">0</span></code> and a standard deviation of <code class="docutils literal notranslate"><span class="pre">1</span></code> for each pixel across the whole sample. This shouldn’t affect training performance since the network can learn to undo this preprocessing.
One difficulty is that if we ever deploy the model, we will have to worry about storing and tracking batch statistics for every training sample that we use to train our models. However, it will be particularly relevant for the discussion about initialization that we will look at below, and hence we perform it here.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>

<span class="n">pixel_values</span> <span class="o">=</span> <span class="n">fixed_batch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

<span class="n">K</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">gaussian_kde</span><span class="p">(</span><span class="n">pixel_values</span><span class="p">)</span>  <span class="c1"># kernel</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">K</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">K</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Density&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Pixel intensity&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_8_0.svg" src="../../_images/04-tensorflow-optim-init_8_0.svg" /></div>
</div>
<p>Next, we define a function for instantiating a neural network. Here <code class="docutils literal notranslate"><span class="pre">activation</span></code> can be any TensorFlow callable function. In particular, functions in the <code class="docutils literal notranslate"><span class="pre">activations</span></code> library of Keras. The initializer in <code class="docutils literal notranslate"><span class="pre">kernel_initializer</span></code> is any valid layer weight initializer for Keras forward layers. In general, any callable that takes <code class="docutils literal notranslate"><span class="pre">shape</span></code> (of the weight tensor to initialize) and <code class="docutils literal notranslate"><span class="pre">dtype</span></code> (of initialized value) can be passed to this argument.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">base_network</span><span class="p">(</span>
    <span class="n">activation</span><span class="p">,</span> 
    <span class="n">kernel_initializer</span><span class="p">,</span>
    <span class="n">num_classes</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> 
    <span class="n">hidden_sizes</span><span class="o">=</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a fully-connected network with given activation and layer widths.&quot;&quot;&quot;</span>

    <span class="c1"># Add hidden layers with activation</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">kr</span><span class="o">.</span><span class="n">Sequential</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hidden_sizes</span><span class="p">)):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="n">kr</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span>
                <span class="n">hidden_sizes</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="n">activation</span><span class="o">=</span><span class="n">activations_by_name</span><span class="p">[</span><span class="n">activation</span><span class="p">],</span>
                <span class="n">kernel_initializer</span><span class="o">=</span><span class="n">kernel_initializer</span><span class="p">,</span>
                <span class="n">bias_initializer</span><span class="o">=</span><span class="s1">&#39;zeros&#39;</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Add linear logits layer</span>
    <span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
        <span class="n">kr</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span>
            <span class="n">units</span><span class="o">=</span><span class="n">num_classes</span><span class="p">,</span>
            <span class="n">kernel_initializer</span><span class="o">=</span><span class="n">kernel_initializer</span><span class="p">,</span>
            <span class="n">bias_initializer</span><span class="o">=</span><span class="s1">&#39;zeros&#39;</span>
        <span class="p">)</span>
    <span class="p">)</span>
    
    <span class="n">model</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">input_shape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">784</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">model</span>
</pre></div>
</div>
</div>
</div>
<p>For the activation functions, we make use of Keras’ <code class="docutils literal notranslate"><span class="pre">activations</span></code> library instead of implementing ourselves. We also use <code class="docutils literal notranslate"><span class="pre">tf.identity</span></code> are our identity activation function. Although this activation function would significantly limit the network’s modeling capabilities, we will use it in the first steps of our discussion about initialization.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">activations_by_name</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;tanh&quot;</span><span class="p">:</span> <span class="n">kr</span><span class="o">.</span><span class="n">activations</span><span class="o">.</span><span class="n">tanh</span><span class="p">,</span>
    <span class="s2">&quot;relu&quot;</span><span class="p">:</span> <span class="n">kr</span><span class="o">.</span><span class="n">activations</span><span class="o">.</span><span class="n">relu</span><span class="p">,</span>
    <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">identity</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we define a few plotting functions that we will use for our discussions. These functions help us to visualize 1) the gradients that the parameters at different layers receive, and 2) the activations, or the output, of the linear layers. The detailed code was hacked into existence based on the resulting visuals, but feel free to take a closer look if interested.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_gradients_distribution</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">activation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;C0&quot;</span><span class="p">,</span> <span class="n">print_variance</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Plot histogram of gradients after one backprop from a batch of inputs.&quot;&quot;&quot;</span>

        <span class="c1"># Get one batch of images</span>
    <span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">fixed_batch</span>

    <span class="c1"># Pass the batch through the network, and calculate the gradients for the weights</span>
    <span class="n">loss_fn</span> <span class="o">=</span> <span class="n">kr</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">SparseCategoricalCrossentropy</span><span class="p">(</span><span class="n">from_logits</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">GradientTape</span><span class="p">(</span><span class="n">persistent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">preds</span><span class="p">)</span>

    <span class="c1"># Exclude the bias to reduce the number of plots</span>
    <span class="n">grads_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">):</span>
        <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">layer</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>

        <span class="c1"># Get kernel weights</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">variables</span><span class="p">)):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">w</span><span class="o">.</span><span class="n">trainable</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;bias&quot;</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">grads_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">grads</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Plotting</span>
    <span class="n">grads_dict_</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">max_n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">grads_dict</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">grads_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">grads_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">grads_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">max_n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))])</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">grads_dict</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">grads_dict_</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">, dense)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grads_dict_</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;logits&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">violinplot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">grads_dict_</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">activation</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;${\nabla}_w L$&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="n">activation</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="c1"># Print variances of each distribution</span>
    <span class="k">if</span> <span class="n">print_variance</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">grads_dict_</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">grads_dict_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">:</span><span class="s2">10</span><span class="si">}</span><span class="s2"> σ²_grad = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span><span class="si">:</span><span class="s2">.5e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">grads_dict</span>


<span class="k">def</span> <span class="nf">plot_activations_distribution</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">activation</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;C0&quot;</span><span class="p">,</span> <span class="n">print_variance</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Plot activation density for output of each layer for one forward pass.&quot;&quot;&quot;</span>

    <span class="c1"># We need to manually loop through the layers to save all activations</span>
    <span class="n">images</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">fixed_batch</span>
    <span class="n">activations</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">activations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">activations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span><span class="p">(</span><span class="n">activations</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Plotting. Skip input and classification layer</span>
    <span class="n">max_n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">activations</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">activations</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>

    <span class="n">activations_</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">activations</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">activations</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">max_n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))])</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">activations</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">activations_</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">activation</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">activations_</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;logits&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
    
    <span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">violinplot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">activations_</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">activation</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;${\phi}$&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="c1"># Print variances of each distribution</span>
    <span class="k">if</span> <span class="n">print_variance</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">activations_</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">activations_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">:</span><span class="s2">10</span><span class="si">}</span><span class="s2"> σ²_act = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span><span class="si">:</span><span class="s2">.5e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">activations</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Remark.</strong> Observe that neurons in the hidden layers are identically distributed during initialization by symmetry. This allows us to combine all values in the <code class="docutils literal notranslate"><span class="pre">(B,</span> <span class="pre">m)</span></code> matrix into a histogram of <code class="docutils literal notranslate"><span class="pre">B*m</span></code> samples whose distribution should reflect the distribution of each individual output neuron. But this doesn’t hold for neurons in the input and output layers which have different distributions. Thus, histogram plots for the input and output layers should be interpreted as an aggregated distribution which will generally differ from individual distributions of each neuron.</p>
</div>
<div class="section" id="initialization">
<h2>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h2>
<p>Training deep neural networks is essentially an optimization problem (in very high dimensions) with the network weights as parameters and the loss as objective. Thus, we have to choose initial values for the weights.
When initializing a neural network, there are a few properties we would like to have.</p>
<p>First, the variance of the input should be propagated through the model to the last layer, so that we have a similar standard deviation for the output neurons. If the variance would vanish the deeper we go in our model, it becomes much harder to optimize the model as the input to the next layer is basically a single constant value. Similarly, if the variance increases, it is likely to explode (i.e. head to infinity) the deeper we design our model. The second property we look out for in initialization techniques is a gradient distribution with equal variance across layers. If the first layer receives much smaller gradients than the last layer, we will have difficulties in choosing an appropriate learning rate.</p>
<p>As a starting point for finding a good method, we will analyze different initialization based on our linear neural network with no activation function (i.e. an identity). We do this because initializations depend on the specific activation function used in the network, and we can adjust the initialization schemes later on for our specific choice.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">base_network</span><span class="p">(</span><span class="n">activation</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;glorot_normal&#39;</span><span class="p">)</span> <span class="c1"># = linear transformation</span>
<span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Model: &quot;sequential&quot;
_________________________________________________________________
 Layer (type)                Output Shape              Param #   
=================================================================
 dense (Dense)               (None, 512)               401920    
                                                                 
 dense_1 (Dense)             (None, 256)               131328    
                                                                 
 dense_2 (Dense)             (None, 256)               65792     
                                                                 
 dense_3 (Dense)             (None, 128)               32896     
                                                                 
 dense_4 (Dense)             (None, 10)                1290      
                                                                 
=================================================================
Total params: 633,226
Trainable params: 633,226
Non-trainable params: 0
_________________________________________________________________
</pre></div>
</div>
</div>
</div>
<p>To easily visualize various initialization schemes, we define the following helper function. Recall that the bias weights are initialized to zero in all subsequent discussion.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">visualize_initialization</span><span class="p">(</span>
    <span class="n">activation</span><span class="p">,</span>
    <span class="n">initialization</span><span class="p">,</span>
    <span class="n">plot_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
    <span class="n">plot_act</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function for visualizing different initialization schemes.&quot;&quot;&quot;</span>
    
    <span class="n">model</span> <span class="o">=</span> <span class="n">base_network</span><span class="p">(</span><span class="n">activation</span><span class="p">,</span> <span class="n">initialization</span><span class="p">)</span>
    <span class="n">gradients</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">activations</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">plot_grad</span><span class="p">:</span>
        <span class="n">gradients</span> <span class="o">=</span> <span class="n">plot_gradients_distribution</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;C1&quot;</span><span class="p">,</span>
            <span class="n">print_variance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">plot_act</span><span class="p">:</span>
        <span class="n">activations</span> <span class="o">=</span> <span class="n">plot_activations_distribution</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> 
            <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;C0&quot;</span><span class="p">,</span> 
            <span class="n">print_variance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;gradients&#39;</span><span class="p">:</span> <span class="n">gradients</span><span class="p">,</span>
        <span class="s1">&#39;activations&#39;</span><span class="p">:</span> <span class="n">activations</span>
    <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="constant-initialization">
<h3>Constant initialization<a class="headerlink" href="#constant-initialization" title="Permalink to this headline">¶</a></h3>
<p>The first initialization we can consider is to initialize all weights with the same constant value. Using a large constant will make the network have exploding activations since neurons accumulate the input vector into a weighted sum. What happens if we set all weights to a value slightly larger or smaller than 0? To find out, we can implement a function for setting all parameters below and visualize the gradients. However, thinking a bit deeper, we see that setting all weights to some constant is not a good idea as the network will have trouble breaking symmetry between neurons.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">visualize_initialization</span><span class="p">(</span>
    <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">,</span>
    <span class="n">initialization</span><span class="o">=</span><span class="n">kr</span><span class="o">.</span><span class="n">initializers</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mf">0.005</span><span class="p">),</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_23_0.svg" src="../../_images/04-tensorflow-optim-init_23_0.svg" /><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, dense) σ²_grad = 1.53186e-22
(2, dense) σ²_grad = 0.00000e+00
(3, dense) σ²_grad = 0.00000e+00
(4, dense) σ²_grad = 0.00000e+00
</pre></div>
</div>
<img alt="../../_images/04-tensorflow-optim-init_23_2.svg" src="../../_images/04-tensorflow-optim-init_23_2.svg" /><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, id)    σ²_act = 2.43055e+00
(2, id)    σ²_act = 1.59289e+01
(3, id)    σ²_act = 2.60978e+01
(4, id)    σ²_act = 4.27587e+01
logits     σ²_act = 1.75140e+01
</pre></div>
</div>
</div>
</div>
<p>As we can see, only the first and the last layer have diverse gradient distributions each intermediate hidden layers have the same gradient for all weights (note that this value is unequal to 0, but very close to it). Due to symmetry, all intermediate neurons belonging to the same layer will be equivalent, and therefore have the same gradient update so that <code class="docutils literal notranslate"><span class="pre">σ²_grad=0.0</span></code>, essentially reducing the effective number of parameters to 1 for these layers.</p>
<p>The only sources of assymetry are the inputs and outputs, which explains the nonzero variance in the gradients of the first and last layers. For example, pixels in the edge of input images have different distributions with pixels on the center.</p>
</div>
<div class="section" id="constant-variance">
<h3>Constant variance<a class="headerlink" href="#constant-variance" title="Permalink to this headline">¶</a></h3>
<p>From the experiment above, we have seen that a constant value is not working. So to break symmetry, how about we initialize the parameters by randomly sampling from a distribution like a Gaussian? The most intuitive way would be to choose one variance that is used for all layers in the network. Let’s implement it below, and visualize the activation distribution across layers.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">visualize_initialization</span><span class="p">(</span>
    <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">,</span>
    <span class="n">initialization</span><span class="o">=</span><span class="n">kr</span><span class="o">.</span><span class="n">initializers</span><span class="o">.</span><span class="n">RandomNormal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stddev</span><span class="o">=</span><span class="mf">0.01</span><span class="p">),</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_27_0.svg" src="../../_images/04-tensorflow-optim-init_27_0.svg" /><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, dense) σ²_grad = 2.61554e-11
(2, dense) σ²_grad = 7.47508e-11
(3, dense) σ²_grad = 1.63786e-10
(4, dense) σ²_grad = 3.14494e-10
</pre></div>
</div>
<img alt="../../_images/04-tensorflow-optim-init_27_2.svg" src="../../_images/04-tensorflow-optim-init_27_2.svg" /><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, id)    σ²_act = 7.69484e-02
(2, id)    σ²_act = 3.94326e-03
(3, id)    σ²_act = 9.83909e-05
(4, id)    σ²_act = 2.63551e-06
logits     σ²_act = 3.31104e-08
</pre></div>
</div>
</div>
</div>
<p>The variance of the activation becomes smaller and smaller across layers and almost vanishes in the last layer. Alternatively, we could use a higher standard deviation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">visualize_initialization</span><span class="p">(</span>
    <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> 
    <span class="n">initialization</span><span class="o">=</span><span class="n">kr</span><span class="o">.</span><span class="n">initializers</span><span class="o">.</span><span class="n">RandomNormal</span><span class="p">(</span><span class="n">stddev</span><span class="o">=</span><span class="mf">0.8</span><span class="p">),</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_29_0.svg" src="../../_images/04-tensorflow-optim-init_29_0.svg" /><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, dense) σ²_grad = 9.50059e+04
(2, dense) σ²_grad = 2.80250e+05
(3, dense) σ²_grad = 5.85746e+05
(4, dense) σ²_grad = 1.19722e+06
</pre></div>
</div>
<img alt="../../_images/04-tensorflow-optim-init_29_2.svg" src="../../_images/04-tensorflow-optim-init_29_2.svg" /><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, id)    σ²_act = 4.88286e+02
(2, id)    σ²_act = 1.59816e+05
(3, id)    σ²_act = 2.61279e+07
(4, id)    σ²_act = 4.54931e+09
logits     σ²_act = 3.91087e+11
</pre></div>
</div>
</div>
</div>
<p>With a higher standard deviation, the activations are likely to explode. We also get vanishing gradients. You can play around with the specific standard deviation values, but it will be hard to find one that gives us a good activation distribution across layers and is very specific to our model. If we would change the hidden sizes or number of layers, you would have to search all over again, which is neither efficient nor recommended!</p>
</div>
<div class="section" id="how-to-find-appropriate-initialization-values">
<h3>How to find appropriate initialization values<a class="headerlink" href="#how-to-find-appropriate-initialization-values" title="Permalink to this headline">¶</a></h3>
<p>Suppose we want to design an initialization for the linear layer which computes <span class="math notranslate nohighlight">\(\mathbf y= \boldsymbol x \boldsymbol W + \boldsymbol b\)</span> with <span class="math notranslate nohighlight">\(\mathbf y\in\mathbb{R}^{n_{\mathbf y}}\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol x\in\mathbb{R}^{n_{\boldsymbol x}}\)</span>. From our experiments above, we saw that we need to optimally sample weights to ensure healthy distribution of activation values. For this, we state two requirements:</p>
<ol class="simple">
<li><p>The mean of the activations should be zero.</p></li>
<li><p>The variance of the activations should stay the same across every layer.</p></li>
</ol>
<p>Note that the activation neurons in a layer are identically distributed as a consequence of symmetry in the MLP network and the <a class="reference external" href="https://en.wikipedia.org/wiki/Central_limit_theorem">Central Limit Theorem</a> (CLT), so we can write the variance as <span class="math notranslate nohighlight">\(\sigma_{\mathbf y}^{2} = \mathbb V(\mathbf{y}_j).\)</span> It follows that <span class="math notranslate nohighlight">\(\boldsymbol b = \boldsymbol 0\)</span> since the bias is constant across different inputs. Next, it makes sense to set the mean of the weights to zero for the sake of symmetry. This also means that we only have to calculate the variance which can be done as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
    \sigma_{\mathbf y}^{2} = \mathbb V(\mathbf{y}_j) &amp; = \mathbb V\left(\sum_{i} \boldsymbol{x}_{i}\boldsymbol{W}_{ij}\right)\\
    &amp; = \sum_{i}\ \mathbb V(\boldsymbol{x}_{i}\boldsymbol{W}_{ij})\\
    &amp; = \sum_{i}\ \mathbb V(\boldsymbol{x}_{i}) \,\mathbb V(\boldsymbol{W}_{ij})\\
    &amp; = n_{\boldsymbol x}\,\mathbb V(\boldsymbol{x}_{i})\,\mathbb V(\boldsymbol{W}_{ij}) = n_{\boldsymbol x}\, \sigma_{\boldsymbol x}^{2} \,\sigma_{\boldsymbol W}^2.
\end{split}
\end{split}\]</div>
<p>Since the columns of <span class="math notranslate nohighlight">\(\boldsymbol W\)</span> are independent of each other, the second line follows from the variance of the sum of independent random variables. On the other hand, the third line follows from the variance of a product of two independent random variables with zero mean. See <a class="reference external" href="https://muchomas.lassp.cornell.edu/8.04/Lecs/lec_statistics/node14.html">here</a> and <a class="reference external" href="https://stats.stackexchange.com/questions/52646/variance-of-product-of-multiple-independent-random-variables">here</a>. Note that <span class="math notranslate nohighlight">\(\boldsymbol x\)</span> also has zero mean  by the inductive hypothesis. Finally, we get the last equality since each <span class="math notranslate nohighlight">\(\boldsymbol{x}_i\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{W}_{ij}\)</span> are identically distributed.</p>
<p><strong>Remark.</strong> As a technical aside, note that while the layers have identical and distributions, and zero mean, the input layer does not. This is not a huge issue, since all analysis can start in the hidden layers, where neurons have approximately zero mean and identical distributions by CLT. Note that CLT only works since each neuron in the input layer has approximately zero mean by our preprocessing methodology.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">base_network</span><span class="p">(</span><span class="n">activation</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;glorot_normal&#39;</span><span class="p">)</span> <span class="c1"># = linear transformation</span>
<span class="n">prep_inputs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">fixed_batch</span>
<span class="n">activations</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">prep_inputs</span><span class="p">}</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">prep_inputs</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">layer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">activations</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>

<span class="c1"># Plot activations distribution for different pixels</span>
<span class="n">cols</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">cols</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">))</span>

<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">activations</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
    <span class="c1"># For input layer, we choose pixels on different local regions of the image.</span>
    <span class="c1"># For hidden layers, all pixels are iid, so we can choose adjacent neurons.</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">500</span> <span class="c1"># pixel indices</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
        
    <span class="n">axk</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">k</span> <span class="o">//</span> <span class="n">cols</span><span class="p">,</span> <span class="n">k</span> <span class="o">%</span> <span class="n">cols</span><span class="p">]</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">activations</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">numpy</span><span class="p">()[:,</span> <span class="n">p1</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">axk</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;C0&quot;</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s1">&#39;density&#39;</span><span class="p">,</span> <span class="n">element</span><span class="o">=</span><span class="s1">&#39;poly&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Pixel </span><span class="si">{</span><span class="n">p1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> 
    <span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">activations</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">numpy</span><span class="p">()[:,</span> <span class="n">p2</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">axk</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;C1&quot;</span><span class="p">,</span> <span class="n">stat</span><span class="o">=</span><span class="s1">&#39;density&#39;</span><span class="p">,</span> <span class="n">element</span><span class="o">=</span><span class="s1">&#39;poly&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Pixel </span><span class="si">{</span><span class="n">p2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">axk</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Activation&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">axk</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Input&quot;</span><span class="p">)</span>
        <span class="n">axk</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axk</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;layer </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">axk</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">axk</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Activation distribution of two neurons in network layers.&quot;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_32_0.svg" src="../../_images/04-tensorflow-optim-init_32_0.svg" /></div>
</div>
<p>Going back to the derivation, it follows that to get <span class="math notranslate nohighlight">\(\sigma^2_{\mathbf y} = \sigma^2_{\boldsymbol x},\)</span> we must have <span class="math notranslate nohighlight">\(\sigma_{\boldsymbol W}^2 = \frac{1}{n_{\boldsymbol x}}.\)</span> That is, we should initialize the weight distribution with a variance equal to the inverse of the layer’s input dimension or number of fan-in neurons. Let’s implement this below and check whether we get better results:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">xavier_fanin</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">fan_in</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">kr</span><span class="o">.</span><span class="n">initializers</span><span class="o">.</span><span class="n">RandomNormal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stddev</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">fan_in</span><span class="p">))(</span><span class="n">shape</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">visualize_initialization</span><span class="p">(</span>
    <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> 
    <span class="n">initialization</span><span class="o">=</span><span class="n">xavier_fanin</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_34_0.svg" src="../../_images/04-tensorflow-optim-init_34_0.svg" /><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, dense) σ²_grad = 7.81915e-05
(2, dense) σ²_grad = 1.60997e-04
(3, dense) σ²_grad = 1.55216e-04
(4, dense) σ²_grad = 3.30697e-04
</pre></div>
</div>
<img alt="../../_images/04-tensorflow-optim-init_34_2.svg" src="../../_images/04-tensorflow-optim-init_34_2.svg" /><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, id)    σ²_act = 9.70865e-01
(2, id)    σ²_act = 9.49525e-01
(3, id)    σ²_act = 9.53343e-01
(4, id)    σ²_act = 8.84497e-01
logits     σ²_act = 8.77540e-01
</pre></div>
</div>
</div>
</div>
<p>As we expected, the variance stays indeed constant across layers. Note that our initialization does not restrict us to a normal distribution, but allows any other distribution with a mean of <span class="math notranslate nohighlight">\(0\)</span> and variance of <span class="math notranslate nohighlight">\(\frac{1}{n_{\boldsymbol x}}.\)</span> You often see that a uniform distribution is used for initialization. A small benefit of using a uniform instead of a normal distribution is that we can exclude the chance of initializing very large or small weights.</p>
<p>In the above plot, we see that gradients slightly vanish nearer the inputs. Indeed, besides the variance of the activations, another variance we would like to stabilize is the one of the gradients.  This ensures a stable optimization for deep networks. From our work on backpropagation on MLPs, we know that
<span class="math notranslate nohighlight">\(\frac{\partial \mathcal L}{\partial \boldsymbol x} = \frac{\partial \mathcal L}{\partial \mathbf y} \boldsymbol W^\top.\)</span>
Hence
<span class="math notranslate nohighlight">\(\sigma^2_{\boldsymbol W^\top} = \sigma^2_{\boldsymbol W} = \frac{1}{n_\mathbf y}.\)</span>
As a compromise between both constraints, in <a class="reference external" href="http://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf?hc_location=ufi">[Glorot and Bengio (2010)]</a> the authors proposed to use the harmonic mean of both values. This leads us to the well-known <strong>Xavier initialization</strong>. For a normal distribution of initial weights, this looks like:</p>
<div class="math notranslate nohighlight">
\[\boldsymbol W\sim \mathcal{N}\left(\mu = 0,\sigma^2=\frac{2}{n_{\boldsymbol x}+n_{\mathbf y}}\right).\]</div>
<p>If we use a uniform distribution, we initialize the weights with:</p>
<div class="math notranslate nohighlight">
\[\boldsymbol W\sim U\left[-\frac{\sqrt{6}}{\sqrt{{n_{\boldsymbol x}+n_{\mathbf y}}}}, \frac{\sqrt{6}}{\sqrt{{n_{\boldsymbol x}+n_{\mathbf y}}}}\right].\]</div>
<p>Let’s shortly implement it and validate its effectiveness:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">xavier</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">fan_in</span><span class="p">,</span> <span class="n">fan_out</span> <span class="o">=</span> <span class="n">shape</span>
    <span class="n">fan_avg</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">fan_in</span> <span class="o">+</span> <span class="n">fan_out</span><span class="p">)</span>
    <span class="n">init</span> <span class="o">=</span> <span class="n">kr</span><span class="o">.</span><span class="n">initializers</span><span class="o">.</span><span class="n">RandomNormal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stddev</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">fan_avg</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">init</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">visualize_initialization</span><span class="p">(</span>
    <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">,</span>
    <span class="n">initialization</span><span class="o">=</span><span class="n">xavier</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_37_0.svg" src="../../_images/04-tensorflow-optim-init_37_0.svg" /><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, dense) σ²_grad = 3.59411e-04
(2, dense) σ²_grad = 6.70388e-04
(3, dense) σ²_grad = 8.85401e-04
(4, dense) σ²_grad = 1.26921e-03
</pre></div>
</div>
<img alt="../../_images/04-tensorflow-optim-init_37_2.svg" src="../../_images/04-tensorflow-optim-init_37_2.svg" /><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, id)    σ²_act = 1.20810e+00
(2, id)    σ²_act = 1.59252e+00
(3, id)    σ²_act = 1.57610e+00
(4, id)    σ²_act = 2.12880e+00
logits     σ²_act = 3.64181e+00
</pre></div>
</div>
</div>
</div>
<p>We see that the Xavier initialization makes the variance of gradients and activations consistent across layers (<code class="docutils literal notranslate"><span class="pre">σ²_act</span></code> around <code class="docutils literal notranslate"><span class="pre">2</span></code> and <code class="docutils literal notranslate"><span class="pre">σ²_grad</span></code> around <code class="docutils literal notranslate"><span class="pre">1e-3</span></code>). Note that the significantly higher variance for the output layer is due to the large difference of input and output dimension (128 vs 10), so that both <code class="docutils literal notranslate"><span class="pre">fan_in</span></code> and <code class="docutils literal notranslate"><span class="pre">fan_out</span></code> differs significantly from <code class="docutils literal notranslate"><span class="pre">fan_avg</span></code>.</p>
<div class="section" id="initialization-for-tanh-networks">
<h4>Initialization for Tanh networks<a class="headerlink" href="#initialization-for-tanh-networks" title="Permalink to this headline">¶</a></h4>
<p>In the discussions above, we assumed the activation function to be linear. So what happens if we add a non-linearity? In a tanh-based network, a common assumption is that for small values during the initial steps in training, the <span class="math notranslate nohighlight">\(\tanh\)</span> works as a linear function such that we don’t have to adjust our calculation. We can check if that is the case for us as well.</p>
<p>Observe that accumulation of activation values with large weights pushes <span class="math notranslate nohighlight">\(\tanh\)</span> activations to <span class="math notranslate nohighlight">\(\pm 1\)</span> which likewise will continue to the rest of the network’s layers. This limits the expressivity of the network.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">visualize_initialization</span><span class="p">(</span>
    <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;tanh&#39;</span><span class="p">,</span>
    <span class="n">initialization</span><span class="o">=</span><span class="n">kr</span><span class="o">.</span><span class="n">initializers</span><span class="o">.</span><span class="n">RandomNormal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stddev</span><span class="o">=</span><span class="mf">0.3</span><span class="p">),</span>
    <span class="n">plot_grad</span><span class="o">=</span><span class="kc">False</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_42_0.svg" src="../../_images/04-tensorflow-optim-init_42_0.svg" /><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, tanh)  σ²_act = 8.92181e-01
(2, tanh)  σ²_act = 8.78982e-01
(3, tanh)  σ²_act = 8.26687e-01
(4, tanh)  σ²_act = 8.21610e-01
logits     σ²_act = 9.04456e+00
</pre></div>
</div>
</div>
</div>
<p>For small fixed <span class="math notranslate nohighlight">\(\sigma,\)</span> we get similar behavior with the identity network since for small input, <span class="math notranslate nohighlight">\(\tanh x \approx x.\)</span> Thus, we get vanishing activations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">visualize_initialization</span><span class="p">(</span>
    <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;tanh&#39;</span><span class="p">,</span>
    <span class="n">initialization</span><span class="o">=</span><span class="n">kr</span><span class="o">.</span><span class="n">initializers</span><span class="o">.</span><span class="n">RandomNormal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stddev</span><span class="o">=</span><span class="mf">0.01</span><span class="p">),</span>
    <span class="n">plot_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_44_0.svg" src="../../_images/04-tensorflow-optim-init_44_0.svg" /><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, tanh)  σ²_act = 6.43426e-02
(2, tanh)  σ²_act = 3.28973e-03
(3, tanh)  σ²_act = 8.34947e-05
(4, tanh)  σ²_act = 2.18588e-06
logits     σ²_act = 2.60761e-08
</pre></div>
</div>
</div>
</div>
<p>Let’s try to initialize with Xavier normalization. This should work fairly well since <span class="math notranslate nohighlight">\(\tanh\)</span> is approximately linear between -1 and 1. Indeed, observe that we get healthier activation distribution compared to initializing the weights with constant variance above!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">visualize_initialization</span><span class="p">(</span>
    <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;tanh&#39;</span><span class="p">,</span>
    <span class="n">initialization</span><span class="o">=</span><span class="n">xavier</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_46_0.svg" src="../../_images/04-tensorflow-optim-init_46_0.svg" /><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, dense) σ²_grad = 2.13943e-05
(2, dense) σ²_grad = 3.90283e-05
(3, dense) σ²_grad = 5.02256e-05
(4, dense) σ²_grad = 8.22868e-05
</pre></div>
</div>
<img alt="../../_images/04-tensorflow-optim-init_46_2.svg" src="../../_images/04-tensorflow-optim-init_46_2.svg" /><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, tanh)  σ²_act = 4.02001e-01
(2, tanh)  σ²_act = 2.85989e-01
(3, tanh)  σ²_act = 1.92777e-01
(4, tanh)  σ²_act = 1.81763e-01
logits     σ²_act = 2.79316e-01
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="initialization-for-relu-networks">
<h4>Initialization for ReLU networks<a class="headerlink" href="#initialization-for-relu-networks" title="Permalink to this headline">¶</a></h4>
<p>But what about ReLU networks? Here, we cannot take the previous assumption of the non-linearity becoming linear for small values.  Suppose <span class="math notranslate nohighlight">\(\mathbf y = \boldsymbol x\boldsymbol W\)</span> such that <span class="math notranslate nohighlight">\(\boldsymbol x\)</span> is an output of a ReLU activated layer. So <span class="math notranslate nohighlight">\(\boldsymbol x\)</span> is not any more zero-centered. But as long as the expectation of <span class="math notranslate nohighlight">\(\boldsymbol W\)</span> is zero and <span class="math notranslate nohighlight">\(\boldsymbol b= \boldsymbol 0\)</span>, the expectation of the output is zero, so we still have mean zero for <span class="math notranslate nohighlight">\(\mathbf y.\)</span> Here our goal is for preactivations to have constant variance and zero mean as this should result in controlled activations. For the latter requirement, the part where the calculation of the ReLU initialization differs from the identity is when determining:</p>
<div class="math notranslate nohighlight">
\[
\mathbb V(\boldsymbol{x}_{i} \boldsymbol{W}_{ij} ) = 
\underbrace{\mathbb{E}[{\boldsymbol{x}_{i}}^2]}_{\mathbb V(\boldsymbol{x}_i)} \;
\underbrace{\mathbb{E} [ {\boldsymbol{W}_{ij}}^2 ]}_{\mathbb V(\boldsymbol{W}_{ij})}
-
\mathbb{E}[ \boldsymbol{x}_{i} ]^2 \; \underbrace{\mathbb{E}[\boldsymbol{W}_{ij}]^2}_{= 0}
= \mathbb{E}[{\boldsymbol{x}_{i}}^2] \; \mathbb V(\boldsymbol{W}_{ij}).
\]</div>
<p>If we assume now that <span class="math notranslate nohighlight">\(\boldsymbol x\)</span> is the output of a ReLU activation, we can calculate the expectation as follows. In the first equality, <span class="math notranslate nohighlight">\(\rho\)</span> is the probability distribution of the values of the preactivation neuron <span class="math notranslate nohighlight">\(z_i\)</span> that outputs <span class="math notranslate nohighlight">\(x_i.\)</span> We can assume that <span class="math notranslate nohighlight">\(\rho\)</span> is symmetric around zero by the inductive hypothesis. Thus</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{split}
\mathbb{E}[{\boldsymbol{x}_i}^2] 
&amp;= \int_{-\infty}^{\infty} \max(0, {a})^2 \rho({a})\, d{a} \\
&amp;= \int_0^{\infty} {a}^2 \rho({a})\, d{a} = \frac{1}{2}\int_{-\infty}^{\infty} {a}^2 \rho({a})\, d{a} = \frac{1}{2}\mathbb V(\boldsymbol{z}_i).
\end{split}\end{split}\]</div>
<p>It follows that</p>
<div class="math notranslate nohighlight">
\[\sigma^2_{\mathbf y} = \frac{1}{2}\sum_{j} \sigma^2_{\boldsymbol W}\, \sigma^2_{ {\boldsymbol{z}}}= \frac{1}{2}\, n_{\boldsymbol{x}}\, \sigma^2_{\boldsymbol W}\, \sigma^2_{\boldsymbol{z}}.\]</div>
<p>Hence, our desired weight variance becomes <span class="math notranslate nohighlight">\(\sigma^2_{\boldsymbol W} = \frac{2}{n_{\boldsymbol x}}.\)</span>
This is known as <strong>Kaiming initialization</strong>. Note that Kaiming initialization does not use the harmonic mean between input and output size. It turns out that using <span class="math notranslate nohighlight">\(n_{\boldsymbol x}\)</span> or <span class="math notranslate nohighlight">\(n_{\mathbf y}\)</span> both lead to stable gradients throughout the network, and only depend on the overall input and output size of the network. Hence, we can use only the input <span class="math notranslate nohighlight">\(n_{\boldsymbol x}.\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">kaiming</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">fan_in</span><span class="p">,</span> <span class="n">fan_out</span> <span class="o">=</span> <span class="n">shape</span>
    <span class="n">init</span> <span class="o">=</span> <span class="n">kr</span><span class="o">.</span><span class="n">initializers</span><span class="o">.</span><span class="n">RandomNormal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stddev</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">fan_in</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">init</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">visualize_initialization</span><span class="p">(</span>
    <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span>
    <span class="n">initialization</span><span class="o">=</span><span class="n">kaiming</span><span class="p">,</span>
    <span class="n">plot_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_49_0.svg" src="../../_images/04-tensorflow-optim-init_49_0.svg" /><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, relu)  σ²_act = 6.98994e-01
(2, relu)  σ²_act = 7.78067e-01
(3, relu)  σ²_act = 7.22222e-01
(4, relu)  σ²_act = 9.11374e-01
logits     σ²_act = 1.64040e+00
</pre></div>
</div>
</div>
</div>
<p>In contrast, having no factor of 2 results in vanishing activation values. The activation variance becomes  unstable across layers.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">visualize_initialization</span><span class="p">(</span>
    <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span>
    <span class="n">initialization</span><span class="o">=</span><span class="n">xavier</span><span class="p">,</span>
    <span class="n">plot_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_51_0.svg" src="../../_images/04-tensorflow-optim-init_51_0.svg" /><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1, relu)  σ²_act = 4.19603e-01
(2, relu)  σ²_act = 2.67133e-01
(3, relu)  σ²_act = 1.32432e-01
(4, relu)  σ²_act = 9.52388e-02
logits     σ²_act = 2.03516e-01
</pre></div>
</div>
</div>
</div>
<p>We can conclude that the Kaiming initialization indeed works well for ReLU-based networks. Note that for other activations we have to slightly adjust the factor in the variance. For instance, for LeakyReLU half of the values are not set to zero anymore, and calculating a similar integral as above results in a factor of <span class="math notranslate nohighlight">\(\frac{2}{1 + \alpha^2}\)</span> instead of <span class="math notranslate nohighlight">\(2\)</span> for the ReLU.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To initialize with different scale factors, Keras implements the <code class="docutils literal notranslate"><span class="pre">VarianceScaling</span></code> initializer which samples weights from a normal distribution with mean zero and standard deviation <code class="docutils literal notranslate"><span class="pre">stddev</span> <span class="pre">=</span> <span class="pre">sqrt(scale/n)</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span></code> depends on the <code class="docutils literal notranslate"><span class="pre">mode</span></code> with <code class="docutils literal notranslate"><span class="pre">'fan_in'</span></code>, <code class="docutils literal notranslate"><span class="pre">'fan_out'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'fan_avg'</span></code> as possible values. In particular, Kaiming corresponds to <code class="docutils literal notranslate"><span class="pre">scale=2</span></code> and <code class="docutils literal notranslate"><span class="pre">mode='fan_in'</span></code>. Xavier corresponds to <code class="docutils literal notranslate"><span class="pre">scale=1</span></code> and <code class="docutils literal notranslate"><span class="pre">mode='fan_avg'</span></code>. Note that same with other normal initializers, Keras truncates the sample space to prevent initializing too large weights.</p>
</div>
</div>
</div>
<div class="section" id="understanding-activation-and-gradient-flow">
<h3>Understanding activation and gradient flow<a class="headerlink" href="#understanding-activation-and-gradient-flow" title="Permalink to this headline">¶</a></h3>
<p>Suppose we index layers and weights as in <a class="reference internal" href="#neuralnet-layers"><span class="std std-numref">Fig. 70</span></a> with <span class="math notranslate nohighlight">\(\boldsymbol x_0\)</span> as input data. It follows that <span class="math notranslate nohighlight">\(\sigma_{\boldsymbol{x}_{t+1}}^{2} = \sigma_{\boldsymbol{x}_{t}}^{2}\,n_{\boldsymbol{x}_{t}}\, \sigma_{\boldsymbol W_t}^2\)</span>  for <span class="math notranslate nohighlight">\(t \geq 1.\)</span> Thus, applying the formula recursively, we get</p>
<div class="math notranslate nohighlight">
\[\sigma_{\boldsymbol{x}_{t}}^{2} =  \sigma_{\boldsymbol{x}_{1}}^{2} \left(\prod_{k=1}^{t-1} n_{\boldsymbol{x}_k}\,\sigma_{\boldsymbol W_k}^2\right)\]</div>
<p>for <span class="math notranslate nohighlight">\(t \geq 1.\)</span> This formula explains why activations and gradients blow up as we go deeper into the layers for a network initialized with sufficiently large constant variance for the weights, and vanishes with depth for sufficiently small constant variance. For example, <span class="math notranslate nohighlight">\(\sigma_{\boldsymbol W_k}^2 = \frac{1}{n_{\boldsymbol{x}_{k}}}\)</span> in Xavier initialization, so that <span class="math notranslate nohighlight">\(\sigma_{\boldsymbol{x}_{t}}^{2} = \sigma_{\boldsymbol{x}_{1}}^{2}.\)</span> Note that we have the same equation for gradients but in the reverse direction (starting from the logits layer) which motivates fan-out Xavier initialization.</p>
<div class="figure align-default" id="neuralnet-layers">
<a class="reference internal image-reference" href="../../_images/neuralnet-layers.png"><img alt="../../_images/neuralnet-layers.png" src="../../_images/neuralnet-layers.png" style="width: 30em;" /></a>
<p class="caption"><span class="caption-number">Fig. 70 </span><span class="caption-text">Schematic diagram of a feedforward neural network.</span><a class="headerlink" href="#neuralnet-layers" title="Permalink to this image">¶</a></p>
</div>
<p>Note that this equation is only an approximation for actual networks since neurons are only approximately independent and identically distributed, and also only have approximately zero mean. But we will test whether our computations are consistent at least in order of magnitude. Recall the identity network initialized with constant variance <span class="math notranslate nohighlight">\(\sigma = 0.8\)</span> had exploding activations while for <span class="math notranslate nohighlight">\(\sigma=0.01\)</span> it had vanishing activations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_activation_formula</span><span class="p">(</span><span class="n">std</span><span class="p">):</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">base_network</span><span class="p">(</span>
        <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> 
        <span class="n">kernel_initializer</span><span class="o">=</span><span class="n">kr</span><span class="o">.</span><span class="n">initializers</span><span class="o">.</span><span class="n">RandomNormal</span><span class="p">(</span><span class="n">stddev</span><span class="o">=</span><span class="n">std</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">activations</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">fixed_batch</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">layers</span><span class="p">):</span>
        <span class="n">activations</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">layer</span><span class="p">(</span><span class="n">activations</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">activations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="n">activations</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="nb">print</span><span class="p">((</span><span class="n">activations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">*</span> <span class="p">(</span><span class="n">std</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span>
    

<span class="c1"># Testing for exploding activations</span>
<span class="n">test_activation_formula</span><span class="p">(</span><span class="n">std</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(158170.74445490958, 156471.62286973)
(25636310.690976568, 25327737.05425358)
(4149696438.968907, 4118834736.8657837)
(337414941644.04504, 332312112399.41016)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Testing for vanishing activations</span>
<span class="n">test_activation_formula</span><span class="p">(</span><span class="n">std</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.004034352758576279, 0.003939023711409251)
(0.00010083900701207682, 0.0001028426230109689)
(2.632771149080804e-06, 2.707619918953261e-06)
(3.465753496260174e-08, 2.7301971702122963e-08)
</pre></div>
</div>
</div>
</div>
<p>For the input layer <span class="math notranslate nohighlight">\(\boldsymbol x_1 = \boldsymbol x_0 \boldsymbol W_0,\)</span> we get <span class="math notranslate nohighlight">\(\frac{\partial \mathcal L}{\partial \boldsymbol W_0} = {\boldsymbol x_0^\top} \frac{\partial \mathcal L}{\partial \boldsymbol x_1}\)</span> by backpropagating from <span class="math notranslate nohighlight">\(\boldsymbol x_1\)</span> to <span class="math notranslate nohighlight">\(\boldsymbol W_0.\)</span> Similarly, we can backpropagate from <span class="math notranslate nohighlight">\(\boldsymbol x_2\)</span> to <span class="math notranslate nohighlight">\(\boldsymbol x_1\)</span> in the next layer <span class="math notranslate nohighlight">\(\boldsymbol x_2 = \boldsymbol x_1 \boldsymbol W_1\)</span> to get
<span class="math notranslate nohighlight">\(\frac{\partial \mathcal L}{\partial \boldsymbol x_1} = \frac{\partial \mathcal L}{\partial \boldsymbol x_2} \boldsymbol W_1^\top.\)</span></p>
<p>Continuing this process, we get the weight gradient of the input layer in terms of the weight gradients of the logits layer <span class="math notranslate nohighlight">\(\boldsymbol x_5\)</span> (which we have easy access to):</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \mathcal L}{\partial \boldsymbol W_0} = {\boldsymbol x_0^\top} \frac{\partial \mathcal L}{\partial \boldsymbol x_5} (\boldsymbol W_1\boldsymbol W_2 \boldsymbol W_3 \boldsymbol W_4)^\top\]</div>
<p>Shifting the starting point to get the gradient of any intermediate layer of the network:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \mathcal L}{\partial \boldsymbol W_t} = {\boldsymbol x_t^\top} \frac{\partial \mathcal L}{\partial \boldsymbol x_d}\left( \boldsymbol{W}_{t+1} \ldots \boldsymbol{W}_{d-1} \right)^\top\]</div>
<p>where <span class="math notranslate nohighlight">\(0 \leq t \leq d-1.\)</span> Notice the stack of weight matrices. This product can explode or vanish depending on the magnitude of the weights. From this formula, we can see why there is vanishing gradients with exploding activations for the identity network initialized with <span class="math notranslate nohighlight">\(\sigma_{ \boldsymbol{W}_{k}} = 0.8.\)</span> Since the activations explode, shallower layers have lower activations, hence get lower weight gradients because of the factor <span class="math notranslate nohighlight">\({\boldsymbol x_t^\top}.\)</span> Moreover the entries of the weights product approaches zero.</p>
<p><strong>Remark.</strong> The formula is similar for general nonlinear activations, but involves the derivative of the activation multiplied (or broadcasted) to the respective weight matrix, so we expect similar behavior for the general case.</p>
<!-- To further check for correctness, we implement the formula for $\frac{\partial \mathcal L}{\partial \boldsymbol W_t}$ in code as follows: --><!-- def weights_gradient_formula(t, model):
    """Formula for computing gradient as a product of weights."""
    
    # Compute activations; here we are careful about indexing
    inputs, targets = fixed_batch
    acts_dict = {}
    x = inputs
    acts_dict[0] = x.numpy() # x0 = input
    for layer_index, layer in enumerate(model.layers):
        x = layer(x)
        acts_dict[layer_index + 1] = x.numpy() # x1 = x0 W0, etc.

    # Compute gradients of logits
    loss_fn = kr.losses.SparseCategoricalCrossentropy(from_logits=True)
    with tf.GradientTape(persistent=True) as tape:
        preds = model(inputs)
        loss = loss_fn(targets, preds)
    preds_grad = tape.gradient(loss, preds).numpy()

    # Compute return value
    X = acts_dict[t]
    weights = [h.get_weights()[0] for h in model.layers]
    if t > len(weights) - 1:
        raise IndexError
    else:
        import functools
        return functools.reduce(
            lambda x, y: x @ y.T, 
            weights[len(weights) - 1: t: -1], # Right multiply weights starting from index 0
            X.T @ preds_grad # Initial factor
        )


def weights_gradient_autodiff(model):
    """Compute gradients using autodifferentiation."""

    images, labels = fixed_batch
    loss_fn = kr.losses.SparseCategoricalCrossentropy(from_logits=True)
    grads_dict = {}
    with tf.GradientTape(persistent=True) as tape:
        loss = loss_fn(labels, model(images))

    for layer_index, layer in enumerate(model.layers):
        grads = tape.gradient(loss, layer.variables[0])
        grads_dict[layer_index] = grads.numpy()

    return grads_dict --><!-- Testing if the above formula works: --><!-- # Fix model
model = base_network(
    activation=None,
    kernel_initializer=xavier,
    hidden_sizes=[512, 256, 256, 128]
)
model.build(input_shape=(None, 784))

# Compute errors for each layer
errors = []
grads_dict = weights_gradient_autodiff(model)
for t in grads_dict.keys():
    W_grad = weights_gradient_formula(t, model)
    e = np.abs(W_grad - grads_dict[t]).max() / np.abs(grads_dict[t]).mean()
    errors.append(e)

plt.plot([str(k) for k in grads_dict.keys()], errors) # force int xticks
plt.xlabel('layer no.')
plt.ylabel('max abs. relative error'); --></div>
</div>
<div class="section" id="optimization">
<h2>Optimization<a class="headerlink" href="#optimization" title="Permalink to this headline">¶</a></h2>
<p>Besides initialization, selecting a suitable optimization algorithm can be an important choice for deep neural networks. First, we need to understand what an optimizer actually does. The optimizer is responsible to update the network’s parameters given the gradients. Hence, we effectively implement a function <span class="math notranslate nohighlight">\({\mathbf w}^{(t)} = f({\mathbf w}^{(t-1)}, {\mathbf g}^{(t)}, ...)\)</span> with <span class="math notranslate nohighlight">\(\mathbf w\)</span> being the parameters, and <span class="math notranslate nohighlight">\({\mathbf g}^{t} = \nabla_{{\mathbf w}^{(t-1)}} \mathcal{L}^{(t)}\)</span> the gradients at time step <span class="math notranslate nohighlight">\(t\)</span>. A common, additional parameter to this function is the learning rate, here denoted by <span class="math notranslate nohighlight">\(\eta\)</span>. Usually, the learning rate can be seen as the “step size” of the update. A higher learning rate means that we change the weights more in the direction of the gradients, a smaller means we take shorter steps.</p>
<div class="section" id="optimization-algorithms">
<h3>Optimization algorithms<a class="headerlink" href="#optimization-algorithms" title="Permalink to this headline">¶</a></h3>
<p>As most optimizers only differ in the implementation of the functional dependence <span class="math notranslate nohighlight">\(f\)</span> of the gradients and the current parameters, we can define a template for an optimizer below. We take as input the parameters of a model and a learning rate. The <code class="docutils literal notranslate"><span class="pre">step()</span></code> function tells the optimizer to update all weights based on their gradients.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">OptimizerTemplate</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">=</span> <span class="n">learning_rate</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grads</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">trainable_variables</span><span class="p">,</span> <span class="n">grads</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_param</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">update_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">grad</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sgd">
<h4>SGD<a class="headerlink" href="#sgd" title="Permalink to this headline">¶</a></h4>
<p>The first optimizer we are going to implement is the standard Stochastic Gradient Descent (SGD). SGD updates the parameters using the following equation:</p>
<div class="math notranslate nohighlight">
\[
\begin{split}
    {\mathbf w}^{(t)} &amp; = {\mathbf w}^{(t-1)} - \eta\, {\mathbf g}^{(t)}.
\end{split}
\]</div>
<p>Let’s implement this in the following class:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SGD</span><span class="p">(</span><span class="n">OptimizerTemplate</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">grad</span><span class="p">):</span>
        <span class="n">dw</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">*</span> <span class="n">grad</span>
        <span class="n">weight</span><span class="o">.</span><span class="n">assign_add</span><span class="p">(</span><span class="n">dw</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="sgd-with-momentum">
<h4>SGD with Momentum<a class="headerlink" href="#sgd-with-momentum" title="Permalink to this headline">¶</a></h4>
<p>SGD can be improved using the concept of <strong>momentum</strong> which replaces the gradient in the update by an exponential average of all past gradients including the current one:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{split}
    \mathbf{m}^{(t)} &amp; = \beta_1 \mathbf{m}^{(t-1)} + (1 - \beta_1)\, {\mathbf g}^{(t)}\\
    {\mathbf w}^{(t)} &amp; = {\mathbf w}^{(t-1)} - \eta\, \mathbf{m}^{(t)}.\\
\end{split}
\end{split}\]</div>
<p>Momentum help smooth out gradient updates. This can be helpful when dealing with oscillating updates.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SGDMomentum</span><span class="p">(</span><span class="n">OptimizerTemplate</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">momentum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="p">{</span><span class="n">w</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">trainable_variables</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">update_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">grad</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">weight</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">weight</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">grad</span>
        <span class="n">dw</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">weight</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="n">weight</span><span class="o">.</span><span class="n">assign_add</span><span class="p">(</span><span class="n">dw</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="adam">
<h4>Adam<a class="headerlink" href="#adam" title="Permalink to this headline">¶</a></h4>
<p>Finally, we arrive at Adam. Adam combines the idea of momentum with an adaptive learning rate, which is based on an exponential average of the squared gradients, i.e. the gradients norm. Furthermore, we add a bias correction for the momentum and adaptive learning rate for the first iterations:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{split}
    {\mathbf{m}}^{(t)} &amp; = \beta_1 {\mathbf{m}}^{(t-1)} + (1 - \beta_1)\, {\mathbf g}^{(t)}\\
    {\mathbf{v}}^{(t)} &amp; = \beta_2 \,{\mathbf{v}}^{(t-1)} \,+ (1 - \beta_2)\, {\mathbf g}^{(t)} \odot {\mathbf g}^{(t)}\\
    \hat{{\mathbf{m}}}^{(t)} &amp;= \frac{{\mathbf{m}}^{(t)}}{1-{\beta_1}^{t}}, \quad \hat{{\mathbf{v}}}^{(t)} = \frac{{\mathbf{v}}^{(t)}}{1-{\beta_2}^{t}}\\
    {\mathbf w}^{(t)} &amp; = {\mathbf w}^{(t-1)} - \frac{\eta}{\sqrt{\hat{{\mathbf{v}}}^{(t)}} + \epsilon} \hat{\mathbf{m}}^{(t)}\\
\end{split}
\end{split}\]</div>
<p>Here <span class="math notranslate nohighlight">\(\epsilon\)</span> is a small constant used to improve numerical stability for very small gradient norms. Remember that the adaptive learning rate does not replace the learning rate hyperparameter <span class="math notranslate nohighlight">\(\eta,\)</span> but rather acts as an extra factor and ensures that the gradients of various parameters have a similar norm.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Adam</span><span class="p">(</span><span class="n">OptimizerTemplate</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">,</span> <span class="n">beta1</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">beta2</span><span class="o">=</span><span class="mf">0.999</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta1</span> <span class="o">=</span> <span class="n">beta1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta2</span> <span class="o">=</span> <span class="n">beta2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>

        <span class="c1"># (t = 0)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="p">{</span><span class="n">w</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">trainable_variables</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="n">w</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">trainable_variables</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_step</span> <span class="o">=</span> <span class="p">{</span><span class="n">w</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">trainable_variables</span><span class="p">}</span> <span class="c1"># time steps for each variable</span>

    <span class="k">def</span> <span class="nf">update_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">grad</span><span class="p">):</span>
        <span class="c1"># fetch prev. momentum and second momentum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">weight</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">weight</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta1</span><span class="p">)</span> <span class="o">*</span> <span class="n">grad</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">weight</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">weight</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">grad</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        
        <span class="c1"># bias correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_step</span><span class="p">[</span><span class="n">weight</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_step</span><span class="p">[</span><span class="n">weight</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="n">m_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">weight</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta1</span><span class="o">**</span><span class="n">t</span><span class="p">)</span>
        <span class="n">v_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">weight</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta2</span><span class="o">**</span><span class="n">t</span><span class="p">)</span>

        <span class="c1"># update weights</span>
        <span class="n">dw</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">*</span> <span class="p">(</span><span class="n">m_hat</span> <span class="o">/</span> <span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">v_hat</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">))</span>
        <span class="n">weight</span><span class="o">.</span><span class="n">assign_add</span><span class="p">(</span><span class="n">dw</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="comparing-optimizers-on-model-training">
<h3>Comparing optimizers on model training<a class="headerlink" href="#comparing-optimizers-on-model-training" title="Permalink to this headline">¶</a></h3>
<p>After we have implemented three optimizers, we can start to analyze and compare them.
First, we test them on how well they can optimize a neural network on the FashionMNIST dataset. We use again our linear network, this time with a ReLU activation and the Kaiming initialization, which we have found before to work well for ReLU-based networks. Note that the model is over-parameterized for this task, and we can achieve similar performance with a much smaller network. However, our main interest is in how well the optimizer can train <em>deep</em> neural networks, hence the over-parameterization.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">metrics</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="k">def</span> <span class="nf">train_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">optim</span><span class="p">,</span> <span class="n">max_epochs</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">256</span><span class="p">):</span>
    <span class="c1"># loss function</span>
    <span class="n">loss_fn</span> <span class="o">=</span> <span class="n">kr</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">SparseCategoricalCrossentropy</span><span class="p">(</span><span class="n">from_logits</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Recall shuffle, batch, repeat pattern to create epochs</span>
    <span class="n">train_loader</span> <span class="o">=</span> <span class="n">train_ds</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">buffer_size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
    <span class="n">train_loader</span> <span class="o">=</span> <span class="n">train_loader</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">train_loader</span> <span class="o">=</span> <span class="n">train_loader</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">max_epochs</span><span class="p">)</span>
    <span class="n">train_loader</span> <span class="o">=</span> <span class="n">train_loader</span><span class="o">.</span><span class="n">prefetch</span><span class="p">(</span><span class="n">buffer_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>    <span class="c1"># Prepare next elements </span>
                                                                    <span class="c1"># while current is preprocessed. </span>
                                                                    <span class="c1"># Trades off latency with memory.</span>
    <span class="n">valid_loader</span> <span class="o">=</span> <span class="n">test_ds</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">buffer_size</span><span class="o">=</span><span class="mi">4096</span><span class="p">)</span>
    <span class="n">valid_loader</span> <span class="o">=</span> <span class="n">valid_loader</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="mi">2048</span><span class="p">)</span>
    <span class="n">valid_loader</span> <span class="o">=</span> <span class="n">valid_loader</span><span class="o">.</span><span class="n">repeat</span><span class="p">()</span>
    <span class="n">valid_iterator</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">valid_loader</span><span class="p">)</span>

    <span class="c1"># training</span>
    <span class="n">train_loss</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">valid_loss</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">valid_acc</span>  <span class="o">=</span> <span class="p">[]</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">x_train</span><span class="p">,</span> <span class="n">y_train</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">train_loader</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">y_train</span><span class="p">,</span> <span class="n">model</span><span class="p">(</span><span class="n">x_train</span><span class="p">))</span>

        <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">trainable_variables</span><span class="p">)</span>
        <span class="n">optim</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">grads</span><span class="p">)</span>
        <span class="n">train_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>

        <span class="c1"># compute valid. loss and valid. accuracy</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">%</span> <span class="n">batch_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x_valid</span><span class="p">,</span> <span class="n">y_valid</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">valid_iterator</span><span class="p">)</span>
            <span class="n">valid_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss_fn</span><span class="p">(</span><span class="n">y_valid</span><span class="p">,</span> <span class="n">model</span><span class="p">(</span><span class="n">x_valid</span><span class="p">)))</span>
            <span class="n">valid_acc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">metrics</span><span class="o">.</span><span class="n">accuracy_score</span><span class="p">(</span>
                    <span class="n">y_valid</span><span class="p">,</span> 
                    <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_valid</span><span class="p">)</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">step</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;train_loss&quot;</span><span class="p">:</span> <span class="n">train_loss</span><span class="p">,</span>
        <span class="s2">&quot;valid_loss&quot;</span><span class="p">:</span> <span class="n">valid_loss</span><span class="p">,</span>
        <span class="s2">&quot;valid_acc&quot;</span><span class="p">:</span> <span class="n">valid_acc</span><span class="p">,</span>
        <span class="s2">&quot;model&quot;</span><span class="p">:</span> <span class="n">model</span>
    <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>For a fair comparison, we train the exact same model with the same initialization with the optimizers below. Listing all optimizers in a dictionary as a function of the model it attaches to. This can be easily extended with additional optimizers that we want to test:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">optimizers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;Adam&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">model</span><span class="p">:</span> <span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">),</span>
    <span class="s1">&#39;SGD&#39;</span><span class="p">:</span>  <span class="k">lambda</span> <span class="n">model</span><span class="p">:</span> <span class="n">SGD</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">),</span>
    <span class="s1">&#39;SGDm&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">model</span><span class="p">:</span> <span class="n">SGDMomentum</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.9</span><span class="p">),</span>
<span class="p">}</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">base_network</span><span class="p">(</span>
    <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> 
    <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;he_normal&#39;</span>
<span class="p">)</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">optim_name</span> <span class="ow">in</span> <span class="n">optimizers</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="n">model_</span> <span class="o">=</span> <span class="n">kr</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">clone_model</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="c1"># e.g. same init</span>
    <span class="n">optim</span> <span class="o">=</span> <span class="n">optimizers</span><span class="p">[</span><span class="n">optim_name</span><span class="p">]</span>
    <span class="n">results</span><span class="p">[</span><span class="n">optim_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_model</span><span class="p">(</span><span class="n">model_</span><span class="p">,</span> <span class="n">optim</span><span class="p">(</span><span class="n">model_</span><span class="p">),</span> <span class="n">max_epochs</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>100%|██████████| 2340/2340 [00:55&lt;00:00, 41.96it/s]
100%|██████████| 2340/2340 [00:30&lt;00:00, 77.37it/s] 
100%|██████████| 2340/2340 [00:57&lt;00:00, 40.36it/s]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">256</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;Adam&#39;</span><span class="p">][</span><span class="s1">&#39;valid_loss&#39;</span><span class="p">]))]</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="n">targets</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="s1">&#39;train_loss&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Train loss&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="mf">2.5</span><span class="p">},</span>
    <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="s1">&#39;valid_loss&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Valid loss&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="mf">2.5</span><span class="p">},</span>
    <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="s1">&#39;valid_acc&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Validation accuracy&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">optim_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">optimizers</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">results</span><span class="p">[</span><span class="n">optim_name</span><span class="p">][</span><span class="n">targets</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;target&#39;</span><span class="p">]],</span> 
            <span class="n">color</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;C</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> 
            <span class="n">label</span><span class="o">=</span><span class="n">optim_name</span><span class="p">,</span> 
            <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>

        <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">targets</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Optimizer steps&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">targets</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;max&#39;</span><span class="p">])</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;dotted&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_83_0.svg" src="../../_images/04-tensorflow-optim-init_83_0.svg" /></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">optim_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">optimizers</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="n">optim_name</span><span class="p">][</span><span class="s1">&#39;valid_loss&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;C</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">optim_name</span><span class="si">}</span><span class="s2"> (valid)&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="n">optim_name</span><span class="p">][</span><span class="s1">&#39;valid_loss&#39;</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">)</span> <span class="c1"># interpolate: cubic</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2304</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2304</span><span class="p">)),</span> <span class="n">color</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">optim_name</span><span class="p">][</span><span class="s1">&#39;train_loss&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;C</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">optim_name</span><span class="si">}</span><span class="s2"> (train)&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Loss&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Optimizer steps&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;dotted&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_84_0.svg" src="../../_images/04-tensorflow-optim-init_84_0.svg" /></div>
</div>
<p>Overall accuracy on the whole test set:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>
<span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">test_ds</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="mi">10000</span><span class="p">)))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test accuracies:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">optim_name</span> <span class="ow">in</span> <span class="n">optimizers</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">optim_name</span><span class="si">:</span><span class="s2">10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="n">optim_name</span><span class="p">][</span><span class="s1">&#39;model&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="mi">100</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Test accuracies:
  Adam       87.93%
  SGD        86.58%
  SGDm       88.37%
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="testing-optimizers-on-exotic-surfaces">
<h3>Testing optimizers on exotic surfaces<a class="headerlink" href="#testing-optimizers-on-exotic-surfaces" title="Permalink to this headline">¶</a></h3>
<p>The result above is that all optimizers perform similarly well with the given model. The differences are too small to find any significant conclusion. However, keep in mind that this can also be attributed to the initialization we chose. When changing the initialization to worse (e.g. constant initialization), Adam usually shows to be more robust because of its adaptive learning rate. To show the specific benefits of the optimizers, we will continue to look at some possible loss surfaces in which momentum and adaptive learning rate are crucial.</p>
<div class="section" id="pathological-curvatures">
<h4>Pathological curvatures<a class="headerlink" href="#pathological-curvatures" title="Permalink to this headline">¶</a></h4>
<p>A pathological curvature is a type of surface that is similar to ravines and is particularly tricky for plain SGD optimization. In words, pathological curvatures typically have a steep gradient in one direction with an optimum at the center, while in a second direction we have a slower gradient towards a (global) optimum. Let’s first create an example surface of this and visualize it:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>

<span class="k">def</span> <span class="nf">plot_surface</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">x_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">y_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">viridis</span><span class="p">):</span>

    <span class="c1"># Plot surface on xy plane; choose 3d or 2d plot</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

    <span class="c1"># Plot    </span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#000&quot;</span><span class="p">,</span> <span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s2">&quot;loss&quot;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
    
    <span class="c1"># Formatting plot</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">x_range</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">y_range</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$w_1$&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$w_2$&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">ax</span>


<span class="k">def</span> <span class="nf">plot_contour</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">x_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">y_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">viridis</span><span class="p">):</span>

    <span class="c1"># Plot surface on xy plane; choose 3d or 2d plot</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    
    <span class="c1"># Plot</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
    
    <span class="c1"># Formatting</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">x_range</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">y_range</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$w_1$&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$w_2$&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">ax</span>
</pre></div>
</div>
</div>
</div>
<p>Consider the function below which has a long, narrow, parabolic shaped flat valley. In terms of optimization, you can image that <span class="math notranslate nohighlight">\(\mathsf{w}_1\)</span> and <span class="math notranslate nohighlight">\(\mathsf{w}_2\)</span> are weight parameters, and the curvature represents the loss surface over the space of <span class="math notranslate nohighlight">\(\mathsf{w}_1\)</span> and <span class="math notranslate nohighlight">\(\mathsf{w}_2\)</span>. Note that in typical networks, we have many, many more parameters than two, and such curvatures can occur in multi-dimensional spaces as well.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pathological_curve_loss</span><span class="p">(</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">):</span>
    <span class="c1"># Example of a pathological curvature. There are many more possible, </span>
    <span class="c1"># feel free to experiment here!</span>
    <span class="n">x1_loss</span> <span class="o">=</span> <span class="n">kr</span><span class="o">.</span><span class="n">activations</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">w1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w1</span><span class="p">)</span>
    <span class="n">x2_loss</span> <span class="o">=</span> <span class="n">kr</span><span class="o">.</span><span class="n">activations</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">w2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x1_loss</span> <span class="o">+</span> <span class="n">x2_loss</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">plot_surface</span><span class="p">(</span><span class="n">pathological_curve_loss</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Pathological curvature&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_93_0.svg" src="../../_images/04-tensorflow-optim-init_93_0.svg" /></div>
</div>
<p>Ideally, our optimization algorithm would find the center of the ravine and focuses on optimizing the parameters towards the direction of <span class="math notranslate nohighlight">\(\mathsf{w}_2\)</span>. However, if we encounter a point along the ridges, the gradient is much greater in <span class="math notranslate nohighlight">\(\mathsf{w}_1\)</span> than <span class="math notranslate nohighlight">\(\mathsf{w}_2\)</span>, and we might end up jumping from one side to the other. Due to the large gradients, we would have to reduce our learning rate slowing down learning significantly.</p>
<p>To test our algorithms, we can implement a simple function to train two parameters on such a surface:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">OptimModel</span><span class="p">(</span><span class="n">kr</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w1</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">init</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w1&#39;</span><span class="p">,</span> <span class="n">trainable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">init</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w2&#39;</span><span class="p">,</span> <span class="n">trainable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_optimizer_path</span><span class="p">(</span><span class="n">optim_fn</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">loss_surface</span><span class="p">,</span> <span class="n">num_steps</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots trajectory of optimizer from initial point (`init`) along </span>
<span class="sd">    a surface (`loss_surface`) in minimizing it via gradient updates. </span>
<span class="sd">    </span>
<span class="sd">    Return: list of 2-tuples which correspond to (x, y) coords of </span>
<span class="sd">    the points in its trajectory.&quot;&quot;&quot;</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">OptimModel</span><span class="p">(</span><span class="n">init</span><span class="p">)</span>
    <span class="n">optim</span> <span class="o">=</span> <span class="n">optim_fn</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">get_weights</span><span class="p">()]</span>
    <span class="n">losses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">trainable_variables</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_surface</span><span class="p">(</span><span class="o">*</span><span class="n">weights</span><span class="p">)</span>

        <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">optim</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">grads</span><span class="p">)</span>
        <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">get_weights</span><span class="p">())</span>
        <span class="n">losses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">losses</span>
</pre></div>
</div>
</div>
</div>
<p>Compute trajectories of gradient descent for the three optimizers starting from <code class="docutils literal notranslate"><span class="pre">(-5,</span> <span class="pre">5)</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_optimizer_path</span><span class="p">(</span><span class="n">optimizers</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">surface_name</span><span class="p">,</span> <span class="n">x_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y_range</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    
    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">optim_name</span> <span class="ow">in</span> <span class="n">optimizers</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">optim</span> <span class="o">=</span> <span class="n">optimizers</span><span class="p">[</span><span class="n">optim_name</span><span class="p">]</span>
        <span class="n">path</span><span class="p">,</span> <span class="n">losses</span> <span class="o">=</span> <span class="n">get_optimizer_path</span><span class="p">(</span><span class="n">optim</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">surface</span><span class="p">)</span>
        <span class="n">results</span><span class="p">[</span><span class="n">optim_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="n">path</span><span class="p">,</span>
            <span class="s1">&#39;losses&#39;</span><span class="p">:</span> <span class="n">losses</span>
        <span class="p">}</span>

    <span class="c1"># Get ranges of coordinates of the optimization trajectories + padding</span>
    <span class="c1"># x = w1 and y = w2, i.e. see ordering on output of get_weights function</span>
    <span class="n">all_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">results</span><span class="p">[</span><span class="n">optim_name</span><span class="p">][</span><span class="s1">&#39;path&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">optim_name</span> <span class="ow">in</span> <span class="n">optimizers</span><span class="o">.</span><span class="n">keys</span><span class="p">()],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">all_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">x_range</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">x_max</span> <span class="o">-</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">+</span> <span class="mf">1.5</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">y_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">all_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">all_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1.5</span><span class="p">)</span>

    <span class="c1"># Plot surface on box defined by coordinate ranges</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    <span class="n">plot_contour</span><span class="p">(</span>
        <span class="n">surface</span><span class="p">,</span> <span class="n">surface_name</span><span class="p">,</span> 
        <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
        <span class="n">x_range</span><span class="o">=</span><span class="n">x_range</span><span class="p">,</span> 
        <span class="n">y_range</span><span class="o">=</span><span class="n">y_range</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Plot trajectory of optimizers</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">optim_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">optimizers</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">optim_name</span><span class="p">][</span><span class="s1">&#39;path&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="n">optim_name</span><span class="p">][</span><span class="s1">&#39;path&#39;</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;C</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>  <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">optim_name</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">optim_name</span><span class="p">][</span><span class="s1">&#39;path&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="n">optim_name</span><span class="p">][</span><span class="s1">&#39;path&#39;</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;C</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>  <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">optim_name</span><span class="p">][</span><span class="s1">&#39;losses&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">optim_name</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.7</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;C</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Optimizer step&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Loss&quot;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">results</span>


<span class="n">optimizers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;Adam&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">model</span><span class="p">:</span> <span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
    <span class="s1">&#39;SGD&#39;</span><span class="p">:</span>  <span class="k">lambda</span> <span class="n">model</span><span class="p">:</span> <span class="n">SGD</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span>
    <span class="s1">&#39;SGDm&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">model</span><span class="p">:</span> <span class="n">SGDMomentum</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.9</span><span class="p">),</span>
<span class="p">}</span>

<span class="n">plot_optimizer_path</span><span class="p">(</span>
    <span class="n">optimizers</span><span class="o">=</span><span class="n">optimizers</span><span class="p">,</span> 
    <span class="n">init</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">],</span> 
    <span class="n">surface</span><span class="o">=</span><span class="n">pathological_curve_loss</span><span class="p">,</span>
    <span class="n">surface_name</span><span class="o">=</span><span class="s1">&#39;Pathological curvature&#39;</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_97_0.svg" src="../../_images/04-tensorflow-optim-init_97_0.svg" /></div>
</div>
<p>We can clearly see that SGD is not able to find the center of the optimization curve and has a problem converging due to the steep gradients (it attempts to go into the minimum a few times). In contrast, Adam and SGD with momentum nicely converge as the changing direction of <span class="math notranslate nohighlight">\(\mathsf{w}_1\)</span> is canceling itself out. On such surfaces, it is crucial to use momentum. Indeed, we used a momentum with value <code class="docutils literal notranslate"><span class="pre">0.9</span></code> which means, the current gradient contributes <code class="docutils literal notranslate"><span class="pre">0.10</span></code> of its original size. Also notice that Adam is the quickest at getting out of the plateau where the optimizers are initialized.</p>
</div>
<div class="section" id="steep-optima">
<h4>Steep optima<a class="headerlink" href="#steep-optima" title="Permalink to this headline">¶</a></h4>
<p>A second type of challenging loss surfaces are steep optima. In those, we have a larger part of the surface having very small gradients while around the optimum, we have very large gradients. For instance, take the following loss surfaces:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bivar_gaussian</span><span class="p">(</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">,</span> <span class="n">x_mean</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y_mean</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">x_sig</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">y_sig</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x_sig</span> <span class="o">*</span> <span class="n">y_sig</span><span class="p">)</span>
    <span class="n">x_exp</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">w1</span> <span class="o">-</span> <span class="n">x_mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x_sig</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">y_exp</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">w2</span> <span class="o">-</span> <span class="n">y_mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">y_sig</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">norm</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x_exp</span> <span class="o">+</span> <span class="n">y_exp</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">comb_func</span><span class="p">(</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">):</span>
    <span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="n">bivar_gaussian</span><span class="p">(</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">,</span> <span class="n">x_mean</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">y_mean</span><span class="o">=-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">x_sig</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">y_sig</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">-=</span> <span class="n">bivar_gaussian</span><span class="p">(</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">,</span> <span class="n">x_mean</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">y_mean</span><span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">x_sig</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">y_sig</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">-=</span> <span class="n">bivar_gaussian</span><span class="p">(</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">,</span> <span class="n">x_mean</span><span class="o">=-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">y_mean</span><span class="o">=-</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">x_sig</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">y_sig</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">z</span>


<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">plot_surface</span><span class="p">(</span><span class="n">comb_func</span><span class="p">,</span> <span class="n">x_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">y_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Steep optima&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_100_0.svg" src="../../_images/04-tensorflow-optim-init_100_0.svg" /></div>
</div>
<p>Most of the loss surface has very little to no gradients. However, close to the optima, we have very steep gradients. To reach the minimum when starting in a region with lower gradients, we expect an adaptive learning rate to be crucial. To verify this hypothesis, we can run our three optimizers on the surface:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">optimizers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;Adam&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">model</span><span class="p">:</span> <span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.2</span><span class="p">),</span>
    <span class="s1">&#39;SGD&#39;</span><span class="p">:</span>  <span class="k">lambda</span> <span class="n">model</span><span class="p">:</span> <span class="n">SGD</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.5</span><span class="p">),</span>
    <span class="s1">&#39;SGDm&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">model</span><span class="p">:</span> <span class="n">SGDMomentum</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.9</span><span class="p">),</span>
<span class="p">}</span>

<span class="n">results</span> <span class="o">=</span> <span class="n">plot_optimizer_path</span><span class="p">(</span>
    <span class="n">optimizers</span><span class="o">=</span><span class="n">optimizers</span><span class="p">,</span> 
    <span class="n">init</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> 
    <span class="n">surface</span><span class="o">=</span><span class="n">comb_func</span><span class="p">,</span>
    <span class="n">surface_name</span><span class="o">=</span><span class="s1">&#39;Steep optima&#39;</span><span class="p">,</span>
    <span class="n">x_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.6</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">),</span>
    <span class="n">y_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.6</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_102_0.svg" src="../../_images/04-tensorflow-optim-init_102_0.svg" /></div>
</div>
<p>Plotting the projections on each axis since it is difficult to see SGD from the contour plot:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">6.5</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

<span class="c1"># Plot x-axis of trajectory of optimizers</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">optim_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">optimizers</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">optim_name</span><span class="p">][</span><span class="s1">&#39;path&#39;</span><span class="p">])</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>   <span class="n">results</span><span class="p">[</span><span class="n">optim_name</span><span class="p">][</span><span class="s1">&#39;path&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;C</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">optim_name</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>   <span class="n">results</span><span class="p">[</span><span class="n">optim_name</span><span class="p">][</span><span class="s1">&#39;path&#39;</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;C</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">optim_name</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">results</span><span class="p">[</span><span class="n">optim_name</span><span class="p">][</span><span class="s1">&#39;losses&#39;</span><span class="p">],</span>     <span class="n">color</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;C</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">optim_name</span><span class="p">)</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;dotted&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$w_1$&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;dotted&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$w_2$&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;dotted&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;steps&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;loss&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/04-tensorflow-optim-init_104_0.svg" src="../../_images/04-tensorflow-optim-init_104_0.svg" /></div>
</div>
<p>SGD first takes very small steps until it touches the border of the optimum at around <code class="docutils literal notranslate"><span class="pre">75</span></code> steps around <code class="docutils literal notranslate"><span class="pre">(-0.5,-0.9)</span></code>. Then, the gradient direction changes and pushes the parameters to <code class="docutils literal notranslate"><span class="pre">(0.5,</span> <span class="pre">0.9)</span></code> from which SGD cannot recover anymore (only with many, many steps). A similar problem has SGD with momentum earlier at around <code class="docutils literal notranslate"><span class="pre">60</span></code> steps, only that it continues the direction of the touch of the optimum. The gradients from this time step are so much larger than any other point that the momentum <span class="math notranslate nohighlight">\({\mathbf{m}}_t\)</span> is overpowered by it despite having the factor <code class="docutils literal notranslate"><span class="pre">0.1</span></code>. Finally, Adam is able to converge in the optimum showing the importance of adaptive learning rates.</p>
</div>
</div>
<div class="section" id="what-optimizer-to-take">
<h3>What optimizer to take<a class="headerlink" href="#what-optimizer-to-take" title="Permalink to this headline">¶</a></h3>
<p>After seeing the results on optimization, what is our conclusion? Should we always use Adam and never look at SGD anymore? The short answer: no. There are many papers saying that in certain situations, SGD (with momentum) generalizes better where Adam often tends to overfit <span id="id1">[<a class="reference internal" href="../../intro.html#id31" title="Ashia C. Wilson, Rebecca Roelofs, Mitchell Stern, Nathan Srebro, and Benjamin Recht. The marginal value of adaptive gradient methods in machine learning. 2017. URL: https://arxiv.org/abs/1705.08292, doi:10.48550/ARXIV.1705.08292.">WRS+17</a>]</span> <span id="id2">[<a class="reference internal" href="../../intro.html#id32" title="Sebastian Ruder. An overview of gradient descent optimization algorithms. CoRR, 2016. URL: http://arxiv.org/abs/1609.04747, arXiv:1609.04747.">Rud16</a>]</span>. This is related to the idea of finding wider optima. For instance, see the illustration of different optima below from <span id="id3">[<a class="reference internal" href="../../intro.html#id30" title="Nitish Shirish Keskar, Dheevatsa Mudigere, Jorge Nocedal, Mikhail Smelyanskiy, and Ping Tak Peter Tang. On large-batch training for deep learning: generalization gap and sharp minima. CoRR, 2016. URL: http://arxiv.org/abs/1609.04836, arXiv:1609.04836.">KMN+16</a>]</span>:</p>
<div class="figure align-default">
<img alt="../../_images/flat_vs_sharp_minima.svg" src="../../_images/flat_vs_sharp_minima.svg" /></div>
<p>The black line represents the training loss surface, while the dotted red line is the test loss. Finding sharp, narrow minima can be helpful for finding the minimal training loss. However, this doesn’t mean that it also minimizes the test loss as especially flat minima have shown to generalize better. You can imagine that the test dataset has a slightly shifted loss surface due to the different examples than in the training set. A small change can have a significant influence for sharp minima, while flat minima are generally more robust to this change.</p>
<p>In the notebook <a class="reference external" href="https://particle1331.github.io/inefficient-networks/notebooks/tensorflow/06-tensorflow-inception.html">Inception, ResNet, and DenseNet</a>, we will see that some network types can still be better optimized with SGD and learning rate scheduling than Adam. Nevertheless, Adam is the most commonly used optimizer in deep learning as it usually performs better than other optimizers especially for deep networks.</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>In this notebook, we looked at initialization and optimization techniques for neural networks. We have seen that a good initialization has to balance maintaining equal gradient variance as well as the activation variance across layers. This can be achieved with the Xavier initialization for tanh-based networks, and the Kaiming initialization for ReLU-based networks. In optimization, concepts like momentum and adaptive learning rate can help with challenging loss surfaces but don’t guarantee an increase in performance for neural networks.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./notebooks/tensorflow"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="03-tensorflow-activations.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Activation Functions</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="05-tensorflow-cnn.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Convolutional Neural Networks</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By 𝗥𝗼𝗻 𝗠𝗲𝗱𝗶𝗻𝗮. Powered by <a href="https://jupyterbook.org">Jupyter Book</a>.<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>